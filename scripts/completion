#!/bin/bash



# partial rewrite of compgen
# mainly to add a separator option
libash_compgen () {
  OPTIND=1
  local opt d=: f=: S='\n' completions comp
  while getopts dfzS: opt; do
    case $opt in
      d) d=;;        # dirnames
      f) f=;;        # filenames
      z) S='\0';;    # NUL delimited
      S) S=$OPTARG;; # OPTARG delimited
    esac
  done
  shift $((OPTIND-1))
  [[ -d $1 && $1 != */ ]] && set -- "$1"/
  completions=("$1"*)
  for comp in "${completions[@]}"; do
    if [[ -f $comp ]]; then
      $f printf "%s$S" "$comp"
    elif [[ -d $comp ]]; then
      $d printf "%s$S" "$comp"
    fi
  done
}

# avoid opening binary files / pictures with vim
_vim () {
  local type path
  case $2 in
    '~') path=$HOME;;
    '~/'*) path=${2/'~'/"$HOME"};;
    *) path=$2;;
  esac
  [[ -d $path ]] && path=${path%/}/
  # read filename
  while read -r -d ''; do
    # mime type (remove : and leading whitespace)
    read -r _ type;
    if [[ $type = text* ]]; then
      [[ $REPLY = "$HOME"/* && $2 = '~'* ]] && REPLY=${REPLY/"$HOME"/'~'}
      COMPREPLY+=("$REPLY")
    fi
  done < <(file --mime-type -0 -L -- "$path"*)
  compopt -o plusdirs
  # FIXME
  # when you're trying to complete ~ without / it doesn't show the directories
}

complete -F _vim vim

# use this in case file fails detect a file as text
# or in huge directories with thousands of file
alias __vim=vim



_busybox () {
  if (( ${#COMP_WORDS[@]} < 3 )); then
    while read -r; do
      [[ $REPLY = "$2"* ]] && COMPREPLY+=("$REPLY")
    done < <(busybox --list)
  else
    #while read -r -d ''; do
      #COMPREPLY+=("$REPLY")
    #done < <(libash_compgen -fz "${COMP_WORDS[COMP_CWORD]}")
    compopt -o bashdefault
    compopt -o default
    compopt -o filenames
  fi
}
complete -D -F _busybox busybox

