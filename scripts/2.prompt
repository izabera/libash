#!/usr/bin/env bash

# saving colors to avoid having to use tput again
if [[ -r /tmp/libash/colors ]]; then
  . /tmp/libash/colors
  declare -gr _black=$_black _red=$_red _green=$_green _yellow=$_yellow _blue=$_blue _magenta=$_magenta _cyan=$_cyan _white=$_white _no_color=$_no_color _colors=("${_colors[@]}")
else
  _black=$(tput setaf 0)
  _red=$(tput setaf 1)
  _green=$(tput setaf 2)
  _yellow=$(tput setaf 3)
  _blue=$(tput setaf 4)
  _magenta=$(tput setaf 5)
  _cyan=$(tput setaf 6)
  _white=$(tput setaf 7)
  _no_color=$(tput sgr 0)
  _colors=("$_black" "$_red" "$_green" "$_yellow" "$_blue" "$_magenta" "$_cyan" "$_white" "$_no_color")
  # declare -p doesn't show the -g attribute
  declare -p _black _red _green _yellow _blue _magenta _cyan _white _no_color _colors > /tmp/libash/colors
  declare -gr _black=$_black _red=$_red _green=$_green _yellow=$_yellow _blue=$_blue _magenta=$_magenta _cyan=$_cyan _white=$_white _no_color=$_no_color _colors=("${_colors[@]}")
fi

return_value () {
  (( $? == 0 )) && printf %s%d%s "$_green" "$?" "$_no_color" || printf %s%d%s "$_red" "$?" "$_no_color"
}

return_status () {
  (( $? == 0 )) && printf %s "$_green" || printf %s "$_red"
}

# /path/to/dir  ->  /p/t/dir
simple_collapsed_wd () {
  local cwd dir i tilde
  cwd=$PWD/ tilde="~"
  IFS=/ read -ra cwd <<< "${cwd/#"$HOME"\//$tilde/}"
  if [[ $cwd ]]; then
    shortcwd="~"
  else
    shortcwd=
  fi
  for (( i = 1; i < ${#cwd[@]}; i ++ )); do
    shortcwd+=/${cwd[i]::1}
  done
  [[ $shortcwd = */?* ]] && shortcwd=${shortcwd%/*}/${cwd[@]: -1}
}

# /path/to/dir  ->  /p/t/dir
# handles collisions correctly!
collapsed_wd () {
  local cwd tilde dir i j pathsofar ambiguous ng dg
  shopt -q nullglob; ng=$?; shopt -s nullglob
  shopt -q dotglob; dg=$?; shopt -s dotglob
  cwd=$PWD/ tilde="~" # bash didn't perform quote removal in the replacement until 4.3
  IFS=/ read -ra cwd <<< "${cwd/#"$HOME"\//$tilde/}"
  if [[ $cwd ]]; then
    shortcwd="~" pathsofar=$HOME
  else
    shortcwd= # if it was empty, the path starts with /
  fi
  for (( i = 1; i < ${#cwd[@]}; i ++ )); do
    pathsofar+=/
    for (( j = 0; j < ${#cwd[i]}; j ++ )); do
      pathsofar+=${cwd[i]:j:1}
      ambiguous=("$pathsofar"*/)  # this is wrong if $PWD is not an existing path BUT THAT'S YOUR FAULT
      [[ ${#ambiguous[@]} -eq 1 ]] && break
    done
    shortcwd+=/${pathsofar##*/}
    pathsofar=${pathsofar%/*}/${cwd[i]}
  done
  [[ $shortcwd = */?* ]] && shortcwd=${shortcwd%/*}/${cwd[@]: -1}
  (( ng )) && shopt -u nullglob
  (( dg )) && shopt -u dotglob
}

#PS1='\[$_green\]\u\[$_no_color\]@\[$_cyan\]\h\[$_no_color\] \[$_red\]\w\[$_no_color\] \[$(return_status)\]\$\[$_no_color\] '

# got the array idea from greycat
PS1='\[$_green\]\u\[$_no_color\]@\[$_cyan\]\h\[$_no_color\] \[$_red\]$shortcwd\[$_no_color\] \[${_colors[$? ? 1 : 2]}\]\$\[$_no_color\] '
PROMPT_COMMAND='collapsed_wd; libash_hook_handler'


simpleprompt () { PROMPT_COMMAND= PS1='\u@\h \w \$ '; tput sgr0; }
