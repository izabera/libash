#!/usr/bin/env bash

# usage: mkdirc a/b/c/d/e/f

mkdirc () {
  if [[ -z $1 || -n $2 ]]; then
    echo "Usage: $0 directory"
    return 1
  else
    mkdir -p "$1" && cd "$1"
  fi
}

# go up and destroy temp directories

uprm () {
  temp=${PWD##*/}
  [[ $temp ]] && cd .. && rm -rf "$temp" # don't delete /
}

# backup your files easily to /backup with a timestamp
# the /backup directory must exist and be writable

backup () {
  local sha
  for file ; do
    read sha _ <<< $(printf %s "$file" | sha1sum)
    cp "$file" "/backup/$(date +%Y-%m-%d-%H-%M-%S)-$sha-${file##*/}"
  done
}

# returns 0 if empty and 1 if not
# if no parameter is specified, uses PWD

isempty () (
  shopt -s dotglob nullglob
  [[ -z $1 ]] && set -- "$PWD"
  files=("$1/"*)
  (( ${#files[@]} > 0 )) && return 1
  return 0
)

# usage: haschanged [-p] file [file...]

haschanged () {
  local parsable=false
  if [[ $1 = "-p" ]] ; then
    parsable=true
    shift
  fi
  [[ $1 = -- ]] && shift
  if ((!$#)) ; then
    "$parsable" && echo 4 || echo "No file selected"
    return 4
  fi
  local filename
  local content
  while (($#)) ; do
    if [[ -f $1 ]]; then
      filename=$(realpath "$1" | base64 | tr / _)
      read hash _ <<< "$(sha1sum "$1")"
      if [[ -f "/tmp/libash/$filename" ]] ; then
        content=$(< "/tmp/libash/$filename")
        if [[ $content = "$hash" ]] ; then
          "$parsable" && echo 0 || echo "Not changed: $1"
        else
          "$parsable" && echo 1 || echo "File changed: $1"
          echo "$hash" > "/tmp/libash/$filename"
        fi
      else
        "$parsable" && echo 2 || echo "New file: $1"
        echo "$hash" > "/tmp/libash/$filename"
      fi
    else
      "$parsable" && echo 3 || echo "Not found: $1"
    fi
    shift
  done
}
