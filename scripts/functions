#!/usr/bin/env bash


# usage: mkdirc a/b/c/d/e/f

mkdirc () {
  if ((!$#)); then
    echo "Usage: $0 directory" >&2
    return 1
  else
    mkdir -p "$1" && cd "$1"
  fi
}


# go up and destroy temp directories
# won't delete $HOME

uprm () {
  temp=${PWD##*/}
  [[ $PWD != "$HOME" ]] && cd .. && rm -rf "$temp"
}


# usage: backup FILE..
# backup your files easily to /backup with a timestamp
# the /backup directory must exist and be writable

backup () {
  local sha
  for file ; do
    read sha _ <<< $(printf %s "$file" | sha1sum)
    cp "$file" "/backup/$(date +%Y-%m-%d-%H-%M-%S)-$sha-${file##*/}"
  done
}


# returns 0 if empty and 1 if not
# if no parameter is specified, uses PWD

isempty () {
  local ret=0 files=() argnum=$#
  (($#)) || set -- "$PWD"
  while (($#)); do
    if [[ ! -d $1 ]]; then
      printf '%s is not a directory\n' "$1"
      shift
      continue
    fi
    files=("$1/"*)
    if (( ${#files[@]} > 0 )); then
      ret=1
      # suppress printing if no arg
      ((argnum)) && printf '%s is not empty\n' "$1"
    fi
    shift
  done
  return "$ret"
}


# usage: haschanged [-p] file [file...]
# -p option is for a parsable output

haschanged () {
  local parsable=false
  if [[ $1 = -p ]] ; then
    parsable=true
    shift
  fi
  [[ $1 = -- ]] && shift
  if ((!$#)) ; then
    "$parsable" && echo 4 || echo "No file selected"
    return 4
  fi
  local filename
  local content
  while (($#)) ; do
    if [[ -f $1 ]]; then
      filename=$(realpath "$1" | base64 | tr / _)
      read hash _ <<< "$(sha1sum "$1")"
      if [[ -f "/tmp/libash/$filename" ]] ; then
        content=$(< "/tmp/libash/$filename")
        if [[ $content = "$hash" ]] ; then
          "$parsable" && echo 0 || echo "Not changed: $1"
        else
          "$parsable" && echo 1 || echo "File changed: $1"
          echo "$hash" > "/tmp/libash/$filename"
        fi
      else
        "$parsable" && echo 2 || echo "New file: $1"
        echo "$hash" > "/tmp/libash/$filename"
      fi
    else
      "$parsable" && echo 3 || echo "Not found: $1"
    fi
    shift
  done
}


# usage: abspath PATH..
# (eg: abspath ..//./path/./to/..//from/../to/./file )
# prints /absolute/path/to/file
# follows symlinks correctly
# returns 0 if the last path of the list is an existing file or directory

abspath () {
  local path
  while (($#)) ; do
    # add an extra / to be removed later on, to help with paths like /path/to/file/..
    path=$1/
    [[ $path = /* ]] || path=$PWD/$path
    while [[ $path = */@(|.|..)/* ]] ; do
      path=${path//\/.\//\/}              # /foo/./bar/      -> /foo/bar/
      path=${path//\/\//\/}               # /foo//bar/       -> /foo/bar/
      path=${path/#\/..\//\/}             # /../foo/         -> /foo/
      path=${path/\/+([!\/])\/..\//\/}    # /foo/bar/../baz/ -> /foo/baz/
    done
    [[ $path = / ]] || path=${path%/}
    echo "$path"
    shift
  done
  test -e "$path"
}


# usage: alarm [HH:MM [message [command args...]]]

alarm () {

  # alarm function without forks \o/
  # unless you want to run a command. in that case it forks \o/

  local alarm=${1:-"$ALARMTIME"}
  [[ $alarm = ??:?? ]] || {
    echo 'Usage: $0 [HH:MM [message [command args...]]]' >&2
    return 1
  }

  # empty msg if $2 is ''
  local msg=${2-"${ALARMMSG-"It's ${alarm}, time to wake up"}"}
  local time

  until 
    printf -v time '%(%T)T'
    printf '\r%s' "$time"
    [[ $time = "$alarm":* ]]
  do
    # when running interactively, bash will use everything that's left
    # in read's buffer after the timeout as part of the next command
    # using -d '' to disable this
    read -t 1 -s -d ''
  done

  printf '\r        \r'
  [[ $msg ]] && printf '%s\n' "$msg"
  if (( $# > 2 )); then 
    shift 2
    "$@"
  fi
}


# usage: searchman page [thing-to-search]
# only works with one page at a time

searchman () {
  MANPAGER="${MANPAGER:-less -sI} ${2++/\"$2\"}" man "${1?Which manual page do you want?}"
}

