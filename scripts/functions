#!/usr/bin/env bash

# usage: mkdirc a/b/c/d/e/f

mkdirc () {
  if [[ -z $1 || -n $2 ]]; then
    echo "Usage: $0 directory"
    return 1
  else
    mkdir -p "$1" && cd "$1"
  fi
}

# go up and destroy temp directories

uprm () {
  temp=${PWD##*/}
  [[ $temp ]] && cd .. && rm -rf "$temp" # don't delete /
}

# backup your files easily to /backup with a timestamp
# the /backup directory must exist and be writable

backup () {
  local sha
  for file ; do
    read sha _ <<< $(printf %s "$file" | sha1sum)
    cp "$file" "/backup/$(date +%Y-%m-%d-%H-%M-%S)-$sha-${file##*/}"
  done
}

# returns 0 if empty and 1 if not
# if no parameter is specified, uses PWD

isempty () (
  shopt -s dotglob nullglob
  [[ -z $1 ]] && set -- "$PWD"
  files=("$1/"*)
  (( ${#files[@]} > 0 )) && return 1
  return 0
)

# usage: haschanged [-p] file [file...]
# -p option is for a parsable output

haschanged () {
  local parsable=false
  if [[ $1 = "-p" ]] ; then
    parsable=true
    shift
  fi
  [[ $1 = -- ]] && shift
  if ((!$#)) ; then
    "$parsable" && echo 4 || echo "No file selected"
    return 4
  fi
  local filename
  local content
  while (($#)) ; do
    if [[ -f $1 ]]; then
      filename=$(realpath "$1" | base64 | tr / _)
      read hash _ <<< "$(sha1sum "$1")"
      if [[ -f "/tmp/libash/$filename" ]] ; then
        content=$(< "/tmp/libash/$filename")
        if [[ $content = "$hash" ]] ; then
          "$parsable" && echo 0 || echo "Not changed: $1"
        else
          "$parsable" && echo 1 || echo "File changed: $1"
          echo "$hash" > "/tmp/libash/$filename"
        fi
      else
        "$parsable" && echo 2 || echo "New file: $1"
        echo "$hash" > "/tmp/libash/$filename"
      fi
    else
      "$parsable" && echo 3 || echo "Not found: $1"
    fi
    shift
  done
}

# usage: resolvepath .././path/./to/../from/../to/./file
# prints /absolute/path/to/file
# returns 0 if that file exists
# TODO: issues with symlinks

resolvepath () {
  (($# != 1)) && return 2
  [[ $1 ]] || return 3
  local path=$1
  [[ ${path::1} != / ]] && path="$PWD/$path"
  # add an extra / to be removed later on, to help with paths like /path/to/file/..
  path="$path/"
  while [[ $path = *//* || $path = */./* || $path = */../* ]] ; do
    path=${path//\/.\//\/}              # /foo/./       -> /foo/
    path=${path//\/\//\/}               # /foo//bar/    -> /foo/bar/
    path=${path/#\/..\//\/}             # /../foo/      -> /foo/
    path=${path/\/+([!\/])\/..\//\/}    # /foo/bar/../  -> /foo/
  done
  [[ $path = / ]] || path="${path%/}"
  printf %s\\n "$path"
  test -e "$path"
}

