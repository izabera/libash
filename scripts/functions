#!/usr/bin/env bash

# usage: mkdirc a/b/c/d/e/f

mkdirc () {
  if (($# == 1)); then
    echo "Usage: $0 directory" >&2
    return 1
  else
    mkdir -p "$1" && cd "$1"
  fi
}

# go up and destroy temp directories
# won't delete $HOME

uprm () {
  temp=${PWD##*/}
  [[ $PWD != "$HOME" ]] && cd .. && rm -rf "$temp"
}

# usage: backup FILE..
# backup your files easily to /backup with a timestamp
# the /backup directory must exist and be writable

backup () {
  local sha
  for file ; do
    read sha _ <<< $(printf %s "$file" | sha1sum)
    cp "$file" "/backup/$(date +%Y-%m-%d-%H-%M-%S)-$sha-${file##*/}"
  done
}

# returns 0 if empty and 1 if not
# if no parameter is specified, uses PWD

isempty () (
  shopt -s dotglob nullglob
  [[ -z $1 ]] && set -- "$PWD"
  files=("$1/"*)
  (( ${#files[@]} > 0 )) && return 1
  return 0
)

# usage: haschanged [-p] file [file...]
# -p option is for a parsable output

haschanged () {
  local parsable=false
  if [[ $1 = "-p" ]] ; then
    parsable=true
    shift
  fi
  [[ $1 = -- ]] && shift
  if ((!$#)) ; then
    "$parsable" && echo 4 || echo "No file selected"
    return 4
  fi
  local filename
  local content
  while (($#)) ; do
    if [[ -f $1 ]]; then
      filename=$(realpath "$1" | base64 | tr / _)
      read hash _ <<< "$(sha1sum "$1")"
      if [[ -f "/tmp/libash/$filename" ]] ; then
        content=$(< "/tmp/libash/$filename")
        if [[ $content = "$hash" ]] ; then
          "$parsable" && echo 0 || echo "Not changed: $1"
        else
          "$parsable" && echo 1 || echo "File changed: $1"
          echo "$hash" > "/tmp/libash/$filename"
        fi
      else
        "$parsable" && echo 2 || echo "New file: $1"
        echo "$hash" > "/tmp/libash/$filename"
      fi
    else
      "$parsable" && echo 3 || echo "Not found: $1"
    fi
    shift
  done
}

# usage: abspath PATH..
# (eg: abspath ..//./path/./to/..//from/../to/./file )
# prints /absolute/path/to/file
# follows symlinks correctly
# returns 0 if the last path of the list is an existing file or directory

abspath () {
  local path
  while (($#)) ; do
    # add an extra / to be removed later on, to help with paths like /path/to/file/..
    path=$1/
    [[ $path = /* ]] || path=$PWD/$path
    while [[ $path = */@(|.|..)/* ]] ; do
      path=${path//\/.\//\/}              # /foo/./bar/      -> /foo/bar/
      path=${path//\/\//\/}               # /foo//bar/       -> /foo/bar/
      path=${path/#\/..\//\/}             # /../foo/         -> /foo/
      path=${path/\/+([!\/])\/..\//\/}    # /foo/bar/../baz/ -> /foo/baz/
    done
    [[ $path = / ]] || path=${path%/}
    echo "$path"
    shift
  done
  test -e "$path"
}

