#!/usr/bin/env bash

readinput () {
  # basic cat replacement that lets you use some editing features
  while read -r -e || { printf %s "$REPLY"; false; } ; do
    printf '%s\n' "$REPLY"
  done
}


shelltest () (
  shells=(bash bsh bush dash jsh ksh mksh pdksh posh zsh)
  while getopts :oOhrs: opt ; do
    case $opt in
      r) resetcolors=true;;
      o) oneline=true;;
      O) oneline=false;;
      h) cat << EOF
Test code with various shells.

Usage: shelltest [options] [shells] -- [parameters for the shell]

Examples: shelltest -O -r
          shelltest bash dash -- -c 'echo foo'    (only two shells)
          shelltest -o -- -- -c 'echo foo'        (default shells)
          shelltest -s csh -s rc -s fish          (three more shells)

If no shell is selected, the following will be tested:
${shells[@]}

Options that follow the -- will be passed to the shell.

Options:  
          -h   print this help
          -o   print in a single line (default)
          -O   print in multiple lines with headers
          -r   reset colors before starting each shell
          -s   select all the default shells + an additional one
EOF
          exit;;
      s) shells+=("$OPTARG") ;;
      :) echo "No shell selected for -$OPTARG" >&2; exit 1;;
      \?) echo "Unknown option: $OPTARG" >&2; exit 1;;
    esac
  done
  shift $((OPTIND-1))

  # select shells
  for opt do
    [[ $opt = -- ]] && shift && break;
    newshells+=("$opt")
    shift
  done

  ((${#newshells[@]})) && shells=("${newshells[@]}")
  "${resetcolors:=false}" || no_color= # defined in libash prompt, undefine it if no -r

  # fake shell to show what will be executed
  input () {
    cat
    printf '%8s: ' args
    printf '%q ' "$@"
    echo
    printf '=======================\n'
  }
  shells=(input "${shells[@]}")

  for shell in "${shells[@]}" ; do
    if "${oneline:=true}" ; then
      printf '%s%8s: ' "$no_color" "$shell"
    else
      printf '%s%s==> %s <==\n' "$no_color" "$var" "$shell"
      var=$'\n'
    fi
    "$shell" "$@" < /dev/fd/0 # abusing herestrings to pass the same input to each shell
  done <<< "$(readinput)"
)
