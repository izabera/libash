#!/bin/bash

# zsh-like correction
command_not_found_handle() {
  if [[ -z $1 ]]; then
    printf "%s: command not found: %s\n" "$0" "$1"
    return 127
  fi
  [[ -r ~/.config/libash/corrections ]] && source ~/.config/libash/corrections
  declare -A {always,maybe}_correct
  local args
  (( $# > 1 )) && printf -v args "%q " "${@:2}"
  if [[ -v 'always_correct[$1]' ]]; then
    eval "${always_correct[$1]} $args"
    return
  fi
  if [[ -v 'maybe_correct[$1]' ]]; then
    ask_correction "$1" "${maybe_correct[$1]}"
    return
  fi
  local cmd
  mapfile -t cmd < <(compgen -c)
  for cmd in "${cmd[@]}"; do
    spdist "$1" "$cmd"
    if (( $? < 3 )); then
      ask_correction "$1" "$cmd"
      return
    fi
  done

  # search for a command that starts with $1 but it's longer than ${#1} + 1 characters
  mapfile -t cmd < <(compgen -c -- "$1")
  if (( ${#cmd[@]} )); then
    ask_correction "$1" "$cmd"
  else
    printf "%s: command not found: %s\n" "$0" "$1"
    return 127
  fi
}

ask_correction() {
  local answer
  printf "%s: correct '%s' to '%s' [nya]? " "$0" "$1" "$2"
  while [[ $answer != [nNyYaA] ]]; do
    read -rsn1 answer
  done
  echo "$answer"
  case $answer in
    A|a) always_correct[$1]=$2
         unset 'maybe_correct[$1]'
         declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null
         eval "${always_correct[$1]}" "$args" ;;
    N|n) printf "%s: command not found: %s\n" "$0" "$1"
         return 127 ;;
    Y|y) maybe_correct[$1]=$2
         declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null
         eval "$2 $args"
  esac
}

# spdist ported from c to bash
# original: lib/sh/spell.c
# TODO: maybe change it to return 0/1
spdist() {
  local cur=$1 new=$2 i
  [[ $1 = "$2" ]] && return # exact match
  while [[ ${1:i:1} = "${2:i:1}" ]]; do (( i++ )); done
  cur=${1:i} new=${2:i}
  if [[ $cur ]]; then
    if [[ $new ]]; then
       [[ ${cur:1} && ${new:1} && ${cur::1} = "${new:1:1}" &&
          ${cur:1:1} = "${new::1}" && ${cur:2} = "${new:2}" ]] &&
          return 1 # transposition
       [[ ${cur:1} = "${new:1}" ]] && return 2 # one character mismatch
    fi
    [[ ${cur:1} = "$new" ]] && return 2 # extra character
  fi
  if [[ $new && ${new:1} = "$cur" ]]; then
    return 2  # missing character
  fi
  return 3
}

# for a faster look up, we only run it once during the installation
typo_cache() {
  [[ -r ~/.config/libash/corrections ]] && source ~/.config/libash/corrections
  declare -A maybe_correct
  local len i cmd tmp
  # random list of commands
  for cmd in bash git sudo python iptables uname node perl wget curl tmux screen \
    "$@"; do
    type -- "$cmd" &>/dev/null || continue
    len=${#cmd}
    # swap two characters
    for (( i = 1; i < len; i++ )); do
      tmp=${cmd:0:i-1}${cmd:i:1}${cmd:i-1:1}${cmd:i+1}
      [[ -v 'maybe_correct[$tmp]' ]] || maybe_correct[$tmp]=$cmd
    done
    # remove characters
    for (( i = 0; i < len; i++ )); do
      tmp=${cmd:0:i}${cmd:i+1}
      [[ -v 'maybe_correct[$tmp]' ]] || maybe_correct[$tmp]=$cmd
    done
  done
  declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null || :
}

