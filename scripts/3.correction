#!/bin/bash

# zsh-like correction
command_not_found_handle() {
  local FUNCNEST=10
  if [[ -z $1 ]]; then
    printf "%s: command not found: %s\n" "$0" "$1" >&2
    return 127
  fi
  [[ -r ~/.config/libash/corrections ]] && source ~/.config/libash/corrections
  declare -A {always,maybe}_correct
  local args
  (( $# > 1 )) && printf -v args "%q " "${@:2}"
  if [[ -v 'always_correct[$1]' ]]; then
    eval "${always_correct[$1]} $args"
    return
  fi
  if [[ -v 'maybe_correct[$1]' ]]; then
    ask_correction "$1" "${maybe_correct[$1]}"
    return
  fi
  local cmd
  # only search for commands that are ${#1} +/-1 long
  while read -r cmd; do
    if spdist "$1" "$cmd"; then
      ask_correction "$1" "$cmd"
      return
    fi
  done < <(compgen -c | awk -v "len=${#1}" '!a[$0]++ && len >= length - 1 && len <= length + 1')

  # search for a command that starts with $1 but it's longer than ${#1} + 1 characters
  if read -r cmd < <(compgen -c -- "$1" | awk -v "len=${#1}" "length > len + 1"); then
    ask_correction "$1" "$cmd"
  else
    if declare -f command_not_found_handle_before_libash &>/dev/null; then
      command_not_found_handle_before_libash
    else
      printf "%s: command not found: %q\n" "$0" "$1" >&2
      return 127
    fi
  fi
}

ask_correction() {
  local answer
  printf "%s: correct '%s' to '%s' [nya]? " "$0" "$1" "$2" >/dev/tty
  while [[ $answer != [nNyYaA] ]]; do
    read -rsn1 answer < /dev/tty
  done
  echo "$answer"
  case $answer in
    A|a) always_correct[$1]=$2
         unset 'maybe_correct[$1]'
         declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null
         eval "${always_correct[$1]}" "$args" ;;
    N|n) printf "%s: command not found: %s\n" "$0" "$1" >/dev/tty
         return 127 ;;
    Y|y) maybe_correct[$1]=$2
         declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null
         eval "$2 $args"
  esac
}

# spdist ported from c to bash
# original: lib/sh/spell.c
spdist() {
  local cur=$1 new=$2 i
  while [[ ${1:i:1} = "${2:i:1}" ]]; do (( i++ )); done
  cur=${1:i} new=${2:i}
  if [[ ${cur:0:1} = "${new:1:1}" && ${cur:1:1} = "${new::1}" &&
        ${cur:1:1} = "${new::1}" && ${cur:2} = "${new:2}" ]]; then return
  elif [[ ${cur:1} = "${new:1}" ]]; then return
  elif [[ ${cur:1} = "$new" ]]; then return
  elif [[ ${new:1} = "$cur" ]]; then return
  else return 1
  fi
}

# for a faster look up, we only run it once during the installation
typo_cache() {
  [[ -r ~/.config/libash/corrections ]] && source ~/.config/libash/corrections
  declare -A maybe_correct
  local len i cmd tmp
  # random list of commands
  for cmd in bash git sudo python iptables uname node perl wget curl tmux screen \
    "$@"; do
    type -- "$cmd" &>/dev/null || continue
    len=${#cmd}
    # swap two characters
    for (( i = 1; i < len; i++ )); do
      tmp=${cmd:0:i-1}${cmd:i:1}${cmd:i-1:1}${cmd:i+1}
      #[[ -v 'maybe_correct[$tmp]' ]] || maybe_correct[$tmp]=$cmd
      maybe_correct[$tmp]=$cmd
    done
    # remove characters
    for (( i = 0; i < len; i++ )); do
      tmp=${cmd:0:i}${cmd:i+1}
      #[[ -v 'maybe_correct[$tmp]' ]] || maybe_correct[$tmp]=$cmd
      maybe_correct[$tmp]=$cmd
    done
  done
  declare -p {always,maybe}_correct > ~/.config/libash/corrections 2>/dev/null || :
}

correct () {
  local arg {always,maybe}_correct
  [[ -r ~/.config/libash/corrections ]] && source ~/.config/libash/corrections
  if (($#)); then   # if with args, set new corrections
    for arg do
      case $arg in
        *=*) always_correct[${arg%%=*}]=${arg#*=} ;;
        *) printf "Error: unknown argument: %s\n" "$arg" ;;
      esac
    done
    declare -p always_correct > ~/.config/libash/corrections 2>/dev/null || :
  else              # otherwise print them
    for arg in "${!always_correct[@]}"; do
      printf "%s=%s\n" "$arg" "${always_correct[$arg]}"
    done
  fi
}
